shell.prefix("source config.sh;")

configfile: "config.json"

import os
import glob
import csv


TN=config["target_names_file"]
REGIONS=[line.rstrip('\n') for line in open(config["target_names_file"])]

LZ   = config["lastz_bin"]
SV   = config["contigsv_bin"]
POST = config["lastz_settings"]

TARGET  = config["target_path"] + config["target_name"]
TARGETI = TARGET + ".fai"
QUERY   = config["query_path"] + config["query_name"]
QUERYI  = QUERY + ".fai"

LQ=config["local_path"] + config["query_name"]

RS_LT= "mkdir -p %s ; rsync  --ignore-existing --bwlimit=50000 -v %s %s" % (config["local_path"], TARGET, config["local_path"])
RS_LTI="mkdir -p %s ; rsync  --ignore-existing --bwlimit=50000 -v %s %s" % (config["local_path"], TARGETI, config["local_path"])
RS_LQ= "mkdir -p %s ; rsync  --ignore-existing --bwlimit=50000 -v %s %s" % (config["local_path"], QUERY, config["local_path"])
RS_LQI="mkdir -p %s ; rsync  --ignore-existing --bwlimit=50000 -v %s %s" % (config["local_path"], QUERYI, config["local_path"])

FAIDX="samtools faidx %s%s" % (config["local_path"], config["target_name"])

rule dummy:
     input: "raw_sv_calls/calls.bed"

rule call:
     input: BAM="all_final_bam/final.sort.bam", BI="all_final_bam/final.sort.bam.bai", TF={TARGET}, QU={QUERY}, BIN={SV}
     output: "raw_sv_calls/calls.bed"
     params: sge_opts=config["cluster_settings"]["light"]
     shell: "{input.BIN} varcall {input.BAM} {input.TF} {input.QU} > {output}"

rule index:
     input : "all_final_bam/final.sort.bam"
     output: "all_final_bam/final.sort.bam.bai"
     params: sge_opts=config["cluster_settings"]["light"]
     shell : "samtools index {input}"

rule posSort:
     input: "all_bam_read_sort/all.read_sort_annotated.bam"
     output: "all_final_bam/final.sort.bam"
     params: sge_opts=config["cluster_settings"]["heavy"]
     shell : "samtools sort -o {output} {input}"

rule annotateBam:
     input:  BAM="all_bam_read_sort/all.read_sort.bam", BIN={SV}
     output: "all_bam_read_sort/all.read_sort_annotated.bam"
     params: sge_opts=config["cluster_settings"]["light"]
     shell:  "{input.BIN} annotate {input.BAM} {output}"

rule readSort:
     input:  "all_bam/all.bam"
     output: "all_bam_read_sort/all.read_sort.bam"
     params: sge_opts=config["cluster_settings"]["light"]
     shell:  "samtools sort -n -l 0 -o {output} {input}"

rule samTobam:
     input:  SAM="all_sam/all.sam",  T={TARGETI}
     output: temp("all_bam/all.bam")
     params: sge_opts=config["cluster_settings"]["light"]
     shell:  "samtools view -bt {input.T} {input.SAM} > {output}"

rule finalMafToSam:
     input : MAF="all_maf/all.maf"
     output: temp("all_sam/all.sam")
     params: sge_opts=config["cluster_settings"]["light"]
     shell:  "maf-convert sam {input.MAF} > {output}"

rule finalAxtToMaf:
     input:  AX="all_axt/all_filt_no_class.axt", TS="stats/target.sizes", QS="stats/query.sizes"
     output: temp("all_maf/all.maf")
     params: sge_opts=config["cluster_settings"]["light"]
     shell: "axtToMaf {input.AX} {input.TS} {input.QS} {output}"

rule netToAxt:
     input:  NET="net/all-no-class.net", CHAIN="merged_chains/all.chain.filter.prenet.chain", TA2="2bits/target.2bit", QU2="2bits/query.2bit"
     output: temp("all_axt/all_filt_no_class.axt")
     params: sge_opts=config["cluster_settings"]["light"]
     shell: "netToAxt {input.NET} {input.CHAIN} {input.TA2} {input.QU2} {output}"

rule filtNet:
     input:  "net/all-no-class.net"
     output: "filt_net/all-no-class.filt.net"
     params: sge_opts=config["cluster_settings"]["light"]
     shell:  "netFilter -chimpSyn {input} > {output} && netToBed {output} filt_net/all-no-class-filter.bed"

rule net:
     input:  CHAIN="merged_chains/all.chain.filter.prenet.chain", TS="stats/target.sizes", QS="stats/query.sizes"
     output: "net/all-no-class.net"
     params: sge_opts=config["cluster_settings"]["light"]
     shell:  "chainNet {input.CHAIN}  -minSpace=1 {input.TS} {input.QS}  stdout /dev/null  |  netSyntenic stdin {output}"

rule filter:
     input:  CHAINS="merged_chains/all.chain", TS="stats/target.sizes", QS="stats/query.sizes"
     params: sge_opts=config["cluster_settings"]["light"]
     output: "merged_chains/all.chain.filter.prenet.chain"
     shell:  "chainPreNet {input.CHAINS} {input.TS} {input.QS} {output}"

rule merge:
     input:  expand("chained_psl/{contig}.chained.psl", contig=REGIONS)
     output: "merged_chains/all.chain"
     params:  sge_opts=config["cluster_settings"]["light"]
     shell:  "chainMergeSort {input} > {output}"

rule chain:
     input:  PSL="raw_psl/{contig}.psl", T2BIT="2bits/target.2bit", Q2BIT="2bits/query.2bit"
     output: temp("chained_psl/{contig}.chained.psl")
     params: sge_opts=config["cluster_settings"]["light"]
     shell:  "axtChain -linearGap=medium -psl {input.PSL} {input.T2BIT} {input.Q2BIT} {output}"

rule lav_to_psl:
     input:  "raw_lav/{contig}.lav"
     output: "raw_psl/{contig}.psl"
     params: sge_opts="-l mfree=10G -l h_rt=24:00:00 -q eichler-short.q"
     shell:  "lavToPsl {input} {output}"

rule runLastZ:
     input:  T={TARGET}, Q={QUERY}
     output: "raw_lav/{contig}.lav"
     params: sge_opts=config["cluster_settings"]["heaviest"]
     shell:  "{RS_LT} ; {RS_LQ} ; {RS_LTI} ; {RS_LQI} ; {FAIDX} {wildcards.contig} > $TMPDIR/q.fasta ; {LZ} $TMPDIR/q.fasta {LQ} {POST} > {output}"

rule stats:
     input:  T={TARGET}, Q={QUERY}
     output: "stats/target.sizes", "stats/query.sizes"
     params: sge_opts=config["cluster_settings"]["light"]
     shell:  "faSize {input.T} -detailed > {output[0]} && faSize {input.Q} -detailed > {output[1]}"

rule twobit:
     input:  T={TARGET}, Q={QUERY}
     output: "2bits/target.2bit", "2bits/query.2bit"
     params: sge_opts=config["cluster_settings"]["heavy"]
     shell:  "faToTwoBit {input.T} {output[0]} && faToTwoBit {input.Q} {output[1]}"

rule faIndexT:
     input:  T={TARGET}
     output: {TARGETI}
     params: sge_opts=config["cluster_settings"]["heavy"]
     shell:  "samtools faidx {input.T}"

rule faIndexQ:
     input:  Q={QUERY}
     output: {QUERYI}
     params: sge_opts=config["cluster_settings"]["heavy"]
     shell:  "samtools faidx {input.Q}"
